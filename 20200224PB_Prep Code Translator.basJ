'[code Descriptive Outline]
'02040608101214161820222426283032343638404244464850525456586062646668707274767880
' Note: Front is Western Courier New regular 10
'       Using Under Score _ try to keep CODE Lines under 80. This allows other
'       reference window; [AA_Convert_PB-JB.log.TXT]; to be used while Coding.

' PB Syntax JB Fix: INSTR(string1, string2[, starting])
'  ___________________________________________________________________________
' /                                                                           \
'| PB to JB TRANSLATION_AID.BAS                                                |
'| 1. Hugh Polley   2020/02/04                                                 |
'|                                                                             |
'| This code is to be considered "public domain".' Feel free to do what you    |
'| want with it. If you come with an improvement please post it here so all    |
'| Basic users get the benefit.                                                |
'| If you make changes to the CODE add your name and date to above listing!    |
'|                                                                             |
'| Disclaimer:                                                                 |
'| This code is provided as-is and it does not have any warranty of any kind.  |
'| User is responsible for any misuse of the code. Do not use this code in     |
'| whole or in part if you can not accept these terms!                         |
' \___________________________________________________________________________/
'
'  ___________________________________________________________________________
' /                                                                           \
'|Purpose: Translation Code Outline for Power Basic BAS files to Just Basic    |
'|    or: Translation Code Outline for Power Basic BAS files to Python Basic   |
' \___________________________________________________________________________/
'
'  ___________________________________________________________________________
' /                                                                           \
'|       MY PAST TRANSLATE PROGRAMS HAD ONE OR MORE OF THESE METHODS           |
'| NOTE: To Accomplish (1-12) run program again as required after each Step    |
'|01. Set [InFile$=PB_file] with (.BAS)] extension                             |
'|02. Allow Program to Create a [!CONTROL] and a [!CONVERT] sub directory!     |
'|03. Place a copy of the [InFile$ .BAS] Program code in [!CONVERT] directory  |
'|04. Program will create an Execution LOG File in CONVERT [AA_PB->JB.log.TXT  |
'|05. Program Creates [AB-Scaned-Code.txt] for last update to converted File!  |
'|    NOTE: control what is executed by deleting records from bottom to top!   |
'|06. Remove LABELS <??##?:> and change to [??##?] Save to Labels.txt          |
'|    At same time GOSUB and GOTO branches are repaired
'|07. Remove Remarks by replacing them with [:REMARK=#####] TO SPELLremarks.TXT|
'|08. Remove Quotes by replacing them with [Quote$(#####)] to SPELLquotes.TXT  |
'|09. To aid in searching for Power Basic Functions and Commands Colins and    |
'|    operators are SPACED! change [?:?] to [? : ?], [?,?] to [? , ?] etc      |
'|10. To Aid in testing of Code changes, Create REM quote + [Space] at the     |
'|    start of each line and a [Space] + REM Quote at end of each line         |
'|11. For each Syntax Change Have Scaned$ = Fixed$, Fixed$=new fix             |
'|    [OPEN Fixed$ FOR OUTPUT] and [OPEN Scaned$ FOR INPUT]                    |
'|12. Highlight lines which need Manual Fix with [< line >]                    |
'|13. For PYTHON Highlight GOTO and Line they branch to with the same Number   |
'|     <## ?? ?> Most can be fixed with DO-LOOP or/and IF-THEN-ELSE and/or     |
'|    CALL or RETURN Subroutine                                                |
'|=============================================================================|
'|Note: back when computer memory was a problem I did [10-12] with READ and    |
'|   DATA statements. Line Numbers and GOTO, GOSUB also required a rework      |
'|exp. Change required GOTO,GOSUB [###], statements that have a value greater  |
'|    than zero! exp. VAL("100") > 0 so change to VAL("z100") = 0  GOSUB 100   |
'|    becomes GOSUB z100                                                       |
' \___________________________________________________________________________/
'
on error goto [ErrorHandler]
GLOBAL InFile$,CONTROL$,CONVERT$,Fixed$,Scaned$,Ln,SUBOFF,Skip
GLOBAL Structure, Syntax, Found, Place
GLOBAL f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14 'open file values
'_____________SET_FILE_NUMBERS________________________________________
f1=1: f2=2: f3=3: f4=4: f5=5: f6=6: f7=7: f8=8: f9=9: f10=10
f11=11: f12=12: f13=13: f14=14
Place=5: Ln=0 'Size of Reference Numbers!
'_________________________________
[NAME.of.BAS.file.TO.be.CONVERTED]
' _____________________________________________________________________
'/                                                                     \
    InFile$="PB_Lotto_Pool.BAS"  '<Change Name of file to be Converted> |
'\_____________________________________________________________________/

Skip=0: Found=0 'recording how many procedures
'______________________________________________________________________________|
[OUTPUTsettingsFORfilesANDlines] Skip=0
Err$="SET [OUTPUTsettingsFORfilesANDlines]<"+str$(Skip)+">"
Err0$=Err$
    CONTROL$="!CONTROL\"
    CONVERT$="!CONVERT\"
    Ln=1
    CLS: print: print tab(Ln);Err$
'______________________________________________________________________________|
[DOESsubdiectory!CONTROLexist] Skip=Skip+1
Err$="SET [DOESsubdiectory!CONTROLexist]<"+str$(Skip)+">"
Err1$=Err$
print tab(Ln);Err$
    result = mkdir( "!CONTROL")
    if result <> 0 then
        print "|_____________________________________|"
        print "| [!CONTROL] directory EXISTS !       |"
        print "| Working Directory for .temp Files!  |"
        print "|-------------------------------------|"
    else
        print "|_____________________________________|"
        print "| [!CONTROL] directory CREATED!       |"
        print "| Working Directory for temp Results! |"
        print "|-------------------------------------|"
        print
        Err$= " {{RUN JB Program Again! }}"
        goto [ErrorHandler]
    end if

'______________________________________________________________________________|
[DOESsubdirectory!CONVERTexist] Skip=Skip+1
Err$="SET [DOESsubdirectory!CONVERTexist]<"+str$(Skip)+">"
Err2$=Err$
print tab(Ln);Err$
    result = mkdir( "!CONVERT")
    if result <> 0 then
        print "|_________________________________________________|"
        print "| [!CONVERT] directory EXISTS!                    |"
        print "| Working Directory for Translation Files !       |"
        print "|-------------------------------------------------|"
        print "  <Locate [";InFile$;"] in [!CONVERT] DIRECTORY!> |"
        print "|_________________________________________________|"
        print
    else
        print "|_________________________________________________|"
        print "| [!CONVERT] directory CREATED!                   |"
        print "| Working Directory for Translation Files !       |"
        print "|-------------------------------------------------|"
        print "| <COPY [";InFile$;"] into [!CONVERT] DIRECTORY!> |"
        print "|_________________________________________________|"
        print
        Err$=" {{ RUN JB Program Again! }}"
        goto [ErrorHandler]
    end if
'______________________________________________________________________________|
[CLEARandCREATElogfile]  Skip=Skip+1
Err$="SET [CLEARandCREATElogfile]<"+str$(Skip)+">"
print tab(Ln);Err$
    ' ___________________________________________________
    '/Create procedure Log File                          \
    open CONVERT$+"AA_PB to JB.log.TXT" for output as #f1
    '\___________________________________________________/
        PRINT #f1,"<"+InFile$+">"
        print #f1, Err0$
        print #f1, Err1$
        print #f1, Err2$
    close #f1
    '\___________________________________________________/
    call logit Space$(Ln)+Err$ 'Line Indent

'______________________________________________________________________________|
[in!CONVERTfindLAST.bas] Skip=Skip+1
Err$="SET [in!CONVERTfindLAST.bas]<"+str$(Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$
    dim info$(100,100) '100 is probably excessive but round
    files DefaultDir$+"\!CONVERT", "*.BAS", info$()
    if val(info$(0,0))=0 then 'a string specifying the qty of files found
        Err$="<"+Err$+" <Empty!>>"
        call logit space$(Ln)+Err$
        print space$(Ln)+Err$
        print "|_________________________________________________|"
        print "| [!CONVERT] directory EXISTS!                    |"
        print "| In Program's Code is <InFile$> set to <??.BAS>  |"
        print "|-------------------------------------------------|"
        print "| <COPY [";InFile$;"] into [!CONVERT] DIRECTORY!> |"
        print "|_________________________________________________|"
        print
        Err$="{{ RUN JB Program Again! }}"
        goto [ErrorHandler]
    end if
'______________________________________________________________________________|
[CHECKforLASTcompletedCODEscan] Skip=Skip+1
Err$="SET [CHECKforLASTcompletedCODEscan]<"+str$(Skip)+">"
call logit space$(Ln)+Err$
'print Err$ is inside procedure

    ' ____________________________________________________________
    '/Translated Just Basic Code Files                            \
    open CONVERT$+"AB-Scaned-Code.txt" for append as #f2: close #f2
    open CONVERT$+"AB-Scaned-Code.txt" for input as #f2
    '\____________________________________________________________/
        Found=0'number of files found used to avoid translating more than needed
        Fixed$="" 'will hold last record in file for procedure Found>skip?
        '____________________________________________________________
        do until eof(#f2)
            input #f2,X$ 
            if len(trim$(X$))>0 then Fixed$=X$: Found=Found+1
        loop
        '-----------------------------------------------------------
     close #f2
     '\___________________________________________________________/
    if len(trim$(Fixed$))=0 then
        open CONVERT$+"AB-Scaned-Code.txt" for output as #f2
            print #f2,InFile$ 
        close #f2
        Err$="<PLACED [";InFile$;"] into [AB-Scaned-Code.txt]!>"
        print tab(Ln+4);Err$
        Err$="{{ RUN JB Program Again! }}"
        goto [ErrorHandler]
    else
        print tab(Ln);Err$+"<# Files Found=";Found;">"
    end if
' _____________________________________________________________________________
'/From this point on Fixed$ is used for File output; Scaned$ is used for File  \
'|input, eg. Scaned$=Fixed$, Fixed$=InFile$+##+des.basJ                         |
'|At this point in Code Skip is = 0, Skip/Found controls where you are at in    |
'|Translation Process! Mess with above Code at your own Risk!     |             |
  Skip=0: print "Decreasing number for each adjustment < -- >": Ln=Ln+4:
'\_____________________________________________________________________________/
'______________________________________________________________________________|
[REPAIRlabelsFROMcolinTObracket] Skip=Skip+1
Err$="M [REPAIRlabelsFROMcolinTObracket]<"+Str$(Found-Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$
If Found>Skip then GOTO [REMOVEremarksTOspell] 'skip to next Task
    ' __________________________________________________
    '/Construct Settings to extract colin labels [##hh:]\
        SUBOFF=0 'turn off log repeats
        Scaned$=Fixed$
        Fixed$=InFile$+".01.Labels.basJ"
    '\__Colin_Labels_Turned_into_box_Labels_[_?_]_______/
    ' _____________________________________________
    '/                                             \
      open CONVERT$+"ZZ_Labels.TXT" for OUTPUT as #21
      open CONTROL$+Fixed$+".temp" for OUTPUT as #11 'temperary code hold
      open CONVERT$+Scaned$ for INPUT as #10 'raw power basic file
    '\_____________________________________________/
        do until EOF(#10) 'search records loop
            ' __________________________________________________________________
            '/search each line for Colin Label                                  \
            line input #10, xx$ 'line record
            '-------------------------------------------------------------------
            if left$(trim$(xx$),1)="'" then goto [do1again] 'line remark found
            ' __________________________________________
            '/Check for colin in line record            \
            Colin=INSTR(xx$,":")
            if Colin=0 then goto [do1again] 'no Colin in line record exit
            ' _______________________________________________________________
            '/Investigate record for criteria which matches with colin label \
            Z=Colin 'is first Colin found inside a double quote?
            InQuote=InsideQuotes(xx$,Z) 'byref xx$: unclosed quotes closed
            if InQuote=0 then 'colin not inside a Quote
                '___Move_Past_serial_spaces__________________
                for T=1 to Colin 'move past spaces
                    if mid$(xx$,T,1)<>space$(1) then exit for
                next T
                if T<Colin then
                    ' ______________________________________________________
                    '/  possible Label Found else bad line found            \
                    for X=T to Colin 'test for alfa numeric chr to Colin
                        yy$=mid$(xx$,X,1)
                        Y=asc(upper$(yy$)) 'for purpose of test
                        Z=(Y>64 and Y<91) or (Y>47 and Y<59) or Y=95'underscore
                        if Z=0 then exit for 'Space of othe chr found before colin
                    next X
                    if Z=0 then goto [do1again] 'non alfa found before colin
                    ' ___________________________________________________
                    '/ Label Found? , fix and record?                    \
                     yy$=left$(xx$,Colin-1)  'extract label without colin
                    ' __________________________________________________
                    '/ Test For not Label but Command                   \
                    restore [COMMANDtest]
                    [COMMANDtest]'some commands will have colin without space
                    data "CLS","LOOP","END","CLOSE","endit" 'here data
                    D$=""
                    do until D$="endit"
                        read D$
                        if D$=upper$(trim$(yy$)) then exit do
                    loop
                    If D$<>"endit" then goto [do1again] 'a command was found
                   ' ______________________________________________
                   '/ repair xx$ and record Label                  \
                    xx$=mid$(xx$,Colin+1)   'beyond colin side of line
                    print #21,trim$(yy$)    'record label
                    'surround label yy$ with spaces for search
                    xx$=Space$(1)+yy$+space$(2)+xx$ 
                    goto [do1again] 'to print out repaired line
                end if
            end if

            '____________________________________
            [do1again] 'replaces nested If ENDif
            print #11,xx$ 'prints to CONTROL$
           '\___Labels_Repaired_and_Recorded_______________________________/
        loop
    ' __________
    '/          \
      close #10
      close #11
      close #21
    '\__________/
'______________________________________________________________________________|
[FIXfoundLABELSandCOLIN] 'no skip as second part of procedure
Err$="M [FIXfoundLABELSandCOLIN]<"+Str$(Found-Skip)+">"
Ln=Ln+4: call logit space$(Ln)+Err$: Ln=Ln-4
print tab(Ln);Err$ 'second part of Label Repair
print "<!wait for process to end!>"
' ____________________________________________
'/Open Temp Repaired File and Continue Repairs\
 open CONVERT$+Fixed$ for OUTPUT as #11
 open CONTROL$+Fixed$+".temp" for INPUT as #10
'\____________________________________________/
    do until EOF(#10)
  ' ____________________________________________
  '/Seperate and Store Remarks                  \
        line input #10, xx$
       ' ___________________________________________
       '/Test for remark inside Quotes              \
        yy0$="":yy1$="":yy2$="":Q=1
        do until Q=0 'seperate out remark
            Q=INSTR(xx$,"'",Q) 'position of Quote
            '------------------------------------
            if Q>0 then 'is Rem inside Quote
                InQuote=InsideQuotes(xx$,Q) 'byref xx$ unclosed quotes closed
                '=======================
                if InQuote>Q then
                    Q=InQuote
                else 'Quote mark found
                    yy0$=mid$(xx$,Q)    'remark
                    xx$=left$(xx$,Q-1)  'before remark
                    exit do
                end if
                '=======================
            end if
            '------------------------------------
        loop
       '\___________________________________________/

        ' ______________________________________
        '/colin add Spaces to each side of Colin\
        Z=1: do until Z=0
            '-------------------------------------
            Z=INSTR(xx$,":",Z) 'position of Colin
            if Z>0 then 'Does Colin needs repair?
                InQuote=InsideQuotes(xx$,Z) 'byref xx$ unclosed quotes closed
                '====================================
                if InQuote>Z then 'quote mark inside quotes
                    Z=InQuote 'continue with check
                else
                    '================================
                    if mid$(xx$,Z-1,1)=space$(1) then 'extract left side colin
                        yy1$=left$(xx$,Z-2)
                    else
                        yy1$=left$(xx$,Z-1)
                    end if
                    '================================
                    if mid$(xx$,Z+1,1)=space$(1) then   'extract right side of colin
                        yy2$=mid$(xx$,Z+2)
                    else
                        yy2$=mid$(xx$,Z+1)
                    end if
                    ' _______________________________________________________
                    '/Reset Z for further check, repair xx$ with colin spaces\
                    yy1$=yy1$+" : "
                    xx$=yy1$+yy2$
                    Z=len(yy1$)
                end if
                '=====================================
            end if
            '--------------------------------------
        loop
       '\________________________________________/

       ' ___________________________________
       '/Load check and repair branch labels\
        open CONVERT$+"ZZ_Labels.TXT" for INPUT as #20
       '\___________________________________/
           ' _______________________________
           '/                               \
            DO UNTIL eof(#20)
                INPUT #20,Label$: Z=1: Label$=trim$(Label$)
                Label$=space$(1)+Label$
                Z=1:tt$=xx$+space$(1)

               ' ________________________
               '/                        \
                do until Z=0
                    Z=INSTR(tt$,Label$,Z)
                    '----------------------------------------------
                    IF Z>0 THEN
                        E=Z+len(Label$) 'check for whole label word
                        '================================
                        if mid$(tt$,E,1)<>space$(1) then
                            Z=E 'label part of a word
                        else

                            yy$="["+trim$(Label$)+"]"+space$(1)
                            yy1$=(left$(tt$,Z))
                            yy2$=mid$(tt$,E)
                            xx$=yy1$+yy$+yy2$
                            Z=E
                       end if
                       '==================================
                    end if
                    '--------------------------------------------
                LOOP
               '\________________________/

            loop
            '\_______________________________/
       ' ___________
       '/           \
        close #20
       '\___________/


        if len(yy0$)>0 then xx$=xx$+yy0$
        print #11,xx$

    loop
   '\_______________________/

' ______________________
'/                      \
 close #10
 close #11
'\______________________/

' __________________________________________________
'/Save to Scanned Controlling Text File             \
  call Record.Repaired.Code
'\__________________________________________________/
Err$="{{ RUN JB Program Again! }}"
'______________________________________________________________________________
goto [ErrorHandler] 'each repair requires rerun in case some Manual repair wanted
'______________________________________________________________________________|
[REMOVEremarksTOspell] Skip=Skip+1
Err$="M [REMOVEremarksTOspell]<"+str$(Found-Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$
If Found>Skip then GOTO [REMOVEquotesTOspell]
    ' _________________________________________
    '/SETUP Variables                          \
        SUBOFF=0
        REMARK=0
        Scaned$=Fixed$
        Fixed$=InFile$+".02.Remark.basJ"
    '\_________________________________________/
    ' ______________________________________________________
    '/OPEN Files for input and Output                       \
        open CONVERT$+"YY_Spell Remarks.TXT" for OUTPUT as #f4
        open CONVERT$+Fixed$ for OUTPUT as #f6
        open CONVERT$+Scaned$ for INPUT as #f5
    '\______________________________________________________/

   ' ________________
   '/                \
    do until EOF(#f5)
        line input #f5, xx$
        '======================
        if left$(trim$(xx$),1)="'" then 'line Remark found
        '-------------------------------------------------
            REMARK=REMARK+1
            Remarkit$=GetNextNumber$(REMARK)
            print #f4, Remarkit$+space$(2)+Rtrim$(xx$)
            print #f6, "REMARK="+trim$(Remarkit$)
        else
        '-------------------------------------------------
            Z=1: Quote$=""
           ' ______________________________________
           '/search for Rem outside of double Quote\
            do until Z=0
                Z = INSTR(xx$,"'",Z)
                if Z=0 then
                '----------------
                    print #f6,xx$ 'print code line
                    exit do '---------------------->
                '-----------------
                end if
                '==============================================================
                InQuote=InsideQuotes(xx$,Z) 'Function returns spot after Quotes
                '----------------------------------------
                if InQuote>Z then 'REM inside a quote found
                '------------------------------------------
                    Z=InQuote 'move along line
                else 'extract line and output remark
                    yy$=trim$(mid$(xx$,Z))
                    xx$=Left$(xx$,Z-1)
                    REMARK=REMARK+1
                    Remarkit$=GetNextNumber$(REMARK)
                    print #f4, Remarkit$+space$(2)+trim$(yy$)
                    print #f6, xx$+" : REMARK="+trim$(Remarkit$)
                    exit do '----------------------------------------->
                '-------------------------------------------
                end if
            loop
            '\_______________________________________/
        '---------------------------------------------------
        end if

    loop
   '\________________/
   ' _________________
   '/Close OPEN Files \
        close #f6
        close #f5
        close #f4
   '\________________/

' __________________________________________________
'/AVE LAST OUTPUT FILE TO CONTROLING TEXT FILE      \
   call Record.Repaired.Code
'\__________________________________________________/
Err$="{{ RUN JB Program Again! }}"
'________________________________________________________________
goto [ErrorHandler]
'______________________________________________________________________________|
[REMOVEquotesTOspell]  Skip=Skip+1
Err$="M [REMOVEquotesTOspell]<"+str$(Found-Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$
    If Found>Skip then GOTO [SPACEitFORsearches]
    ' _________________________________________
    '/SETUP Variables                          \
        SUBOFF=0
        Quote=0
        Quote$="Quote$(??)"
        Scaned$=Fixed$
        Fixed$=InFile$+".03.Quote.basJ"
    '\_________________________________________/

   ' ______________________________________________________
    '/OPEN Files for input and Output                       \
        open CONVERT$+"XX-Spell Quotes.TXT" for OUTPUT as #f9
        open CONVERT$+Fixed$ for OUTPUT as #f7
        open CONVERT$+Scaned$ for INPUT as #f8
    '\______________________________________________________/
   ' ________________
   '/                \
    Quote=0
    do until EOF(#f8)
        line input #f8, xx$
        '----------------------------------------------
        if left$(trim$(xx$),1)="'" then 'line Remark found
            print #f7,xx$
        else
           ' ________________
           '/                \
            Z=1: do until Z=0
                Z = INSTR(xx$,chr$(34),Z) 'find quote
                '----------------
                if Z=0 then
                    print #f7,xx$ 
                    exit do '----------->
                end if
                Start=Z: Z=Z+1
                if ASC(mid$(xx$,Z,1))=34 then
                    Z=Z+1 'Double Quote ignore
                else
                    'position after Quote in xx$
                    '-----------------
                    InQuote=InsideQuotes(xx$,Z) 'byref xx$ unclosed quotes closed
                    '----------------------------------------
                    if InQuote>Z then 'Second Quote Found
                        Last=InQuote-1
                        Z=InQuote 'continue quote line check
                        Y1$=Left$(xx$,Start-1)
                        Y2$=mid$(xx$,Start+1,Last-Start-1)
                        Y3$=trim$(mid$(xx$,Last+1))
                        yy$=Y2$
                        Quote=Quote+1: Quote$=GetNextNumber$(Quote)
                        Y2$="Quote$("+str$(Quote)+") "
                        '-----------------------------------------
                        xx$=Y1$+Y2$: Z=len(xx$)+1 'Z reset to new val
                        '------------------------------------------
                        xx$=xx$+Y3$
                        print #f9,Quote$+space$(2)+trim$(yy$)
                        '-------------------------------->
                    else 'Code Problem?
                        cls
                        print "'here2"
                        print xx$
                        print InQuote,Z,mid$(xx$,Z,1)
                        print
                        input "hit";T$
                        call logit "ERROR Quote? "+xx$
                        print #f7,"[ERRORquote]"+xx$
                        Z=0
                    end if
                end if

            loop
            '\____________/

        end if
        '---------------------------------------------------
    loop
   '\________________/
   ' _________________
   '/Close OPEN Files \
        close #f7
        close #f8
        close #f9
   '\________________/
' __________________________________________________________________
'/                                                                  \
if  REMARK>Quote then Dim Record$(REMARK+1) else Dim Record$(Quote+1)
'\__________________________________________________________________/
' __________________________________________________
'/ AVE LAST OUTPUT FILE TO CONTROLING TEXT FILE     \
    call Record.Repaired.Code
'\__________________________________________________/
Err$="{{ RUN JB Program Again! }}"
'______________________________________
goto [ErrorHandler]
'______________________________________
Function GetNextNumber$(Number)
    Number$="0000000"+str$(Number)
    GetNextNumber$=right$(Number$,Place)
end function
'______________________________________________________________________________|
[SPACEitFORsearches] Skip=Skip+1
Err$="M [SPACEitFORsearches] "+str$(Found-Skip)
call logit space$(Ln)+Err$
print tab(Ln);Err$
If Found>Skip then GOTO [structureREMOVElines]
    '_______________________________________
    Scaned$=Fixed$
    Fixed$=InFile$+".04.Spaced.basJ"
    '=======================================
   ' _______________________________________
   '/OPEN Files for input and Output        \
    open CONVERT$+Fixed$ for OUTPUT as #11
    open CONVERT$+Scaned$ for INPUT as #10
   '\________________________________________/
   ' __________________________________________________________
   '/Check and space repair each line PB Code xx$ Line         \
    do until EOF(#10)
        line input #10,xx$
        ' ___________________________________________________________
        '/Space it Out Data: any operator or divider you can think of\
        [SPACEitDATA]
         data "OR","AND","'",",","(",")","=","*","-","+","^","#"
         data "<",">","endit" 'here data
        '\__________________________________________________________/
       '___________________________________
        do'Check for Data Items in the Line\
            read Item$: if Item$="endit" then exit do
           ' _________________________________________
            Z=1 'Do loop: Check and Repair Found Items\
            do until Z=0 'Item$ not in line remander   \
            '-------------------------------------------
                Z = INSTR(xx$,Item$,Z) 'check for item
                '---------------------
                if Z=0 then exit do             'item not found
                Y3$=trim$(mid$(xx$,Z+1))    'right side of line whole trim
                Y1$=Rtrim$(Left$(xx$,Z-1))  'left side of line part trim
                if Item$ ="#" then
                    Y2$=space$(1)+Item$
                else
                    Y2$=space$(1)+Item$+space$(1)
                end if
                xx$=Y1$+Y2$
                Z=len(xx$)+1  'reset Z for continuing line search
                xx$=xx$+Y3$ 'repair line with space seperators
                '----------------------
            loop 'line for each occurance of item
           '\_____________________________________/
        loop until Item$ = "endit"
       '\_________________________________/

       print #11,"' "+Rtrim$(xx$)+" '"
       '-------------------------------------
       restore [SPACEitDATA] ' Item Data List
       '-------------------------------------
    loop 'for each PB code line
   '\___________________________________________________________/
   ' _________________
   '/Close OPEN Files \
        close #11
        close #10
   '\________________/
' __________________________________________________
'/Save to Controlling Text File                     \
    call Record.Repaired.Code
'\__________________________________________________/
 Err$="{{ RUN JB Program Again! }}"
'___________________________________________________
goto [ErrorHandler]
'___________________________________________________
[structureREMOVElines] Skip=Skip+1
Err$="M [structureREMOVElines]"+"<"+str$(Found-Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$
'________________________________________
If Found>Skip then goto [structureCONST]
'=======================================
    ' ____________________________________________________________________
    '/SETUP Variables                                                     \
      SUBOFF=0
      Scaned$=Fixed$
      Fixed$=InFile$+".05.Removed.basJ"
    '\____________________________________________________________________/
    ' _____________________________________________________________________
    '/                                                                     \
     open CONVERT$+"VV-"+InFile$+".LinesRemoved.TXT" for output as #12: close #12
     open CONVERT$+Fixed$ for OUTPUT as #11
     open CONVERT$+Scaned$ for INPUT as #10
    '\_____________________________________________________________________/
    do until eof(#10)
        line input #10,test$
        test$=RemoveLines$ (test$) 'removes lines with READ in DATA
        if len(test$)>0 then
          print #11,test$
        end if
    loop
   ' _________________
   '/Close OPEN Files \
        close #11
        close #10
   '\_________________/

' __________________________________________________
'/Save to Controlling Text File                     \
    call Record.Repaired.Code
'\__________________________________________________/
 Err$="{{ RUN JB Program Again! }}"
'____________________________________________
 goto [ErrorHandler]
'_____________________________________
function RemoveLines$ (test$)
[DATArestore]
    DATA " #CONSOLE ON "," #COMPILE EXE "," #REGISTER "," #DEBUG ERR "
    DATA " DEFLNG "," MACRO ","Endit" 'here data
 restore [DATArestore]

        while Remove$<>"Endit"
            read Remove$
            Z=instr(test$,Remove$)
            if Z>0 then  'un-needed line found
                open CONVERT$+"VV-"+InFile$+".LinesRemoved.TXT" for append as #12
                    print #12,test$
                close #12
                test$=""
                EXIT WHILE
            end if
        wend
        RemoveLines$=test$ 'will be empty if removal takes place
end function
'____________________________________________
[structureCONST] Skip=Skip+1
Err$="M [structureCONST] <"+str$(Found-Skip)+">"
call logit space$(Ln)+Err$
print tab(Ln);Err$
'________________________________________
If Found>Skip then goto [NextOperation]
'=======================================
    ' _________________________________________
    '/SETUP Variables                          \
        SUBOFF=0
        Find$=" CONST "
        Scaned$=Fixed$
        Fixed$=InFile$+".06.CONST.basJ"
    '\_________________________________________/
   ' ___________________________________________________________________
   '/OPEN Files for input and Output                                    \
      open CONVERT$+"WW_"+InFile$+".GLOBAL.TXT" for output as #12: close #12
      open CONVERT$+Fixed$ for OUTPUT as #11
      open CONVERT$+Scaned$ for INPUT as #10
    '\__________________________________________________________________/

    do until eof(#10)
        line input #10,xx$

        Z = INSTR(xx$,Find$)
        if Z>0 then
            ' ________________________________________
            '/ CONST found
            yy2$=mid$(xx$,Z+len(Find$)) 'right of line after construct
            Z1=instr(yy2$,"="): IF Z1=0 then goto [BAILonIF]
            Global$=trim$(left$(yy2$,Z1-1))
            xx$=yy2$                    '
           ' _____________________________________________________
           '/Save for addition to Global Statements               \
            open CONVERT$+"WW_"+InFile$+".GLOBAL.TXT" for append as #12
                print #12,Global$
            close #12
           '\_____________________________________________________/
        end if
        [BAILonIF]
        print #11,xx$
    loop
   ' _________________
   '/Close OPEN Files \
        close #11
        close #10
   '\_________________/
' __________________________________________________
'/Save to Controlling Text File                     \
    call Record.Repaired.Code
'\__________________________________________________/
 Err$="{{ RUN JB Program Again! }}"
'____________________________________________
 goto [ErrorHandler]
'________________________________________________________
[NextOperation] 'place new operations before this line
'________________________________
goto [ErrorHandler]
'________________________________

'===================================================
' ______________________________________________________
'/END OF REQUIRED OPERATIONS, REST OF TRANSLATIONS CAN  \
'|BE FOR EITHER PYTHON OR JUST BASIC, DO NOT RUN AS EXE |
'|IT IS CONSTRUCTED TO FIX CODE PROBLEMs AS ENCOUNTERED |
'|NEXT LOAD [B TranslatePB-jb.basJ] to Continue making  |
'|changes to the PB code. It will use AB_Scaned-Code.txt|
'|to capture the PB File Name.                          |
'========================================================
'______________________________________________________________________________|
[PREtranslatorOUTPUTcompleted] 'final run will have Found>Skip
print "  __________________________________________________  "
print " / Preparation for Translating Code Complete!       \ "
print "| TO CONTINUE TRANSLATING in JUST BASIC or PYTHON    |"
print "| LOAD: [PB_Syntax Code Translator] INTO JB EDITOR!  |"
print "| RUN and and Adjust or Add to JB Code as needed!    |"
print " \__________________________________________________/ "

'_________________________________________________________
[ErrorHandler] 'NOTIFICATION OF END OF EXECUTION OR ERROR \
'\__Place SUB OR FUNCTION CALLS here only when no error!__/

    if Err>0 then
        print
        print " ___________________________________________"
        print "/          ERROR MESSAGE                    "
        if Err$<>"" then print "{"+Err$+"}"
        print "Error number is {";Err;"}"
        print "\__________END OF MESSAGE___________________"
    else
        print
        print " ___________________________________________"
        print "/          LAST PROCEDURE                   "
        print " {"+Err$+"}"
        print "\___________OR MESSAGE______________________"

       if Found>Skip then
            Ln=1: call logit "EH [END OF PROGRAM EXECUTION]"
        print " ___________________________________________"
        print "/          OUTPUTED FILE                   "
        print "   Program has Returned the Checked"
        print "   Code to Program ["+Fixed$+"]"
        print "\______________THE_END______________________"
        end if
    end if


' __________________________________________________________________
'/  PROPER END TO PROGRAM EXECUTION AND ERROR HANDLING              \
                    END                                             '|
'|  3 RETURN without GOSUB                                           |
'|  4 Read past end of data                                          |
'|  8 Branch label not found                                         |
'|  9 Subscript out of range                                         |
'|  11 Division by zero                                              |
'|  53 OS Error: The system cannot find the file specified.          |
'|  58 OS Error: Cannot create a file when that file already exists. |
'|  55 Error opening file                                            |
'|  52 Bad file handle                                               |
'|  62 Input past end of file                                        |
'|                                                                   |
'\____________START OF FUNCTIONS AND SUBROTINES______________________/
'__________________________________________________
sub Record.Repaired.Code 'Fixed,CONVERT$ are Global
' __________________________________________________
'/Save to Controlling Text File                     \
open CONVERT$+"AB-Scaned-Code.txt" for append as #f2
    print #f2,Fixed$ 'last file created or repaired
close #f2
'\__________________________________________________/
end sub
'__________________________
[LOGtoCONTROLprocessedFILE]
sub logit itlog$
    open CONVERT$+"AA_PB to JB.log.TXT" for APPEND as #f1
        print #f1,SPACE$(L)+itlog$
    close #f1
end sub
'_______________________
FUNCTION Ltrim$(String$)
    do
        if trim$(String$)="" then String$="": exit do
        If left$(String$,1)=space$(1) then String$=mid$(String$,2) else exit do
    loop until String$=Trim$(String$)
    Ltrim$=String$
end function
'_______________________
FUNCTION Rtrim$(String$)
    do
        if trim$(String$)="" then String$="": exit do
        If Right$(String$,1)=space$(1) then
            String$=mid$(String$,1,len(String$)-1)
        else
            exit do
        end if
    loop until String$=Trim$(String$)
    Rtrim$=String$
end function

FUNCTION InsideQuotes(byref xx$,Z) 'closes open quotes
IF SUBOFF=0 THEN
    Ln=Ln+4: call logit_
    space$(Ln)+"F InsideQuotes( xx$,Z) 'Move past double quotes in xx$"
    print tab(Ln); Err$: Ln=Ln-4: SUBOFF=1
END IF
     IF  Z = 0 THEN EXIT FUNCTION  'Z must be >0 to search for inside Quotes
     Y = 1 :  X = 1
     DO UNTIL  Y = 0
        Y = INSTR(xx$,CHR$(34), X)
        IF  Y > 0 THEN 'first quote found
              X =  Y + 1
              W = INSTR(xx$,CHR$(34), X)
             IF  W > 0 THEN 'closing quote found
                  X =  W + 1
                 IF  Z >  Y AND  Z <  W THEN 'return next position outside of quotes
                     InsideQuotes =  X
                     EXIT FUNCTION
                 END IF
             else 'closing Quote not found add Quote
                xx$= xx$+CHR$(34)
                Y = 1: X = 1
             END IF
         END IF
     LOOP
END FUNCTION

'_______________________________________________
FUNCTION Search.For.Ref$(Ref$,LastRecord)
Err$="Search_For_Ref("+Ref$+")"
    Namey$=Ref$
    Namey=val(Ref$)

    TopRecord = 1
    BottomRecord = LastRecord
    do
        MidPoint = INT((TopRecord + BottomRecord) / 2)
        test = val(LEFT$(Record$(MidPoint),LEN(Namey$)))
        IF test = Namey THEN EXIT DO '---------------->
        IF Namey>test THEN
            TopRecord = MidPoint + 1
        ELSE
            BottomRecord = MidPoint - 1
        END IF
    LOOP UNTIL (TopRecord > BottomRecord)
      ' ______________________________________________________________________
      '/Found Record Set to value$ without Ref number                         \
        IF test = Namey THEN
            Search.For.Ref$=mid$(Record$(MidPoint),LEN(Namey$)+3)
        else
            Search.For.Ref$ ="No_Quote_Found"
        end if
      '\______________________________________________________________________/

END FUNCTION
'______________________________________________
sub Return.Code.Quotes Scaned$,Fixed$,FileIn$
Err$="Return.Code.Quotes Scaned$,Fixed$,FileIn$"
Ln=Ln+4: call logit "S "+Err$

    ' _________________________________________________________
    '/ Load Record$() with Quote Records                       \
    open CONVERT$+FileIn$ for input as #f14
        N=0: do until eof(#f14): line input #f14,T$: N=N+1: loop
    close #f14

    Redim  Record$(N+1)
    open CONVERT$+FileIn$ for input as #f15
        N=0
        do until eof(#f15)
            line input #f15,T$: N=N+1
            Record$(N)=T$
        loop
    close #f15
    '\_________________________________________________________/

    LastRecord=N
   ' ________________________________________________________
   '/Search for Quote = ref points                           \
    open CONVERT$+Fixed$ for output as #f11
    open CONVERT$+Scaned$ for Input as #f10
   '\________________________________________________________/
        EmptyLines=0: FoundPlace=0 'Place limit of ref number
        do until eof(#f10)
            line input #f10,xx$
            Q=1 'set so loop works
            do until Q=0
                Q=instr(xx$,"Quote$(",Q)
                if Q>0 then
                    S=Q+7 'start of ref #
                    R=instr(xx$,")",S)'end of number
                    P=R+1: R=R-1  'P right side of line, R end of number
                    RF=val(mid$(xx$,S,R-S+1)) 'ref value
                    Y1$=Left$(xx$,Q-1) 'left side of line
                    Y3$=mid$(xx$,P)    'right side of line
                    Namey$="0000000"+str$(RF)
                    Namey$=right$(Namey$,Place) 'place is length of Ref
                    Y2$=Search.For.Ref$(Namey$,LastRecord)
                    Q=S 'move search point just in case Y2$=""
                    if len(Y2$)>0 then
                        Y2$=chr$(34)+Y2$+chr$(34)
                        xx$=Y1$+Y2$
                        Q=len(xx$)
                        xx$=xx$+Y3$
                        QuotePlace=QuotePlace+1
                    else
                        EmptyQuotes=EmptyQuotes+1
                    end if
                end if
            loop
            print #f11,xx$
        loop
    ' _________________
    '/Close OPEN Files \
     close #f10
     close #f11
    '\_________________/
     if RemarkMissed>0 then print "Remarks Missed=";RemarkMissed
     Ln=Ln+4
     call logit "Quotes Missed=";EmptyQuotes
     call logit "Quotes Found=";QuotePlace
     Ln=Ln-8

end sub
'______________________________________________
sub Return.Code.Remarks Scaned$,Fixed$,FileIn$
Err$="Return.Code.Remarks Scaned$,Fixed$,FileIn$"
Ln=Ln+4: call logit "S "+Err$
    ' _________________________________________________________
    '/ How many records in Remark file                         \
    open CONVERT$+FileIn$ for input as #f14
        N=0: do until eof(#f14): line input #f14,T$: N=N+1: loop
    close #f14
    ' __________________________________________
    '/empty and size array for Search of Remarks\
            Redim  Record$(N+1)
    '\__________LOAD Record$()__________________/
    open CONVERT$+FileIn$ for input as #f15
        N=0
        do until eof(#f15)
            line input #f15,T$: N=N+1
            Record$(N)=T$
        loop
    close #f15
    '\_________________________________________________________/

    LastRecord=N 'number of records in array to be searched
   ' ________________________________________________________
   '/Search for Quote = ref points                           \
    open CONVERT$+Fixed$ for output as #f11
    open CONVERT$+Scaned$ for Input as #f10
   '\________________________________________________________/
        RemarkMissed=0: RemarkFound=0 'Holds record of search
       ' ________________________________________________________
       '/Return Remarks to BAS Code                              \
        do until eof(#f10)
            line input #f10,xx$
            Q=instr(xx$,": REMARK="): if Q=0 then Q=instr(xx$," REMARK=")
            '____________________________________________________________
            if Q>0 then
                do until Q=0 'error exit loop
            '___________Remark_Record_Found______________________________
                    S=Q: Q=0 'start of remark ref
                    R=instr(xx$,"=",S)+1 'start of ref number
                    if R=0 then exit do '---------------->
                    E=R+Place 'end of ref#
                    '__GET_REF_NUMBER_____________
                    Namey$=TRIM$(mid$(xx$,R,Place))
                    Y1$=Left$(xx$,S-1) 'left side of line
                    Y3$=mid$(xx$,S)    'eliminated right side of line
                    Y2$=Search.For.Ref$(Namey$,LastRecord)
                    if len(Y2$)>0 then
                        xx$=Y1$+Y2$
                        RemarkFound=RemarkFound+1
                    else
                        RemarkMissed=RemarkMissed+1
                    end if
                 loop
            end if
            '____________________________________________________________

            print #f11,xx$
        loop
       '\_As_Action_Code_ends_with_Remark_so_does_search_of_line_/
    ' _________________
    '/Close OPEN Files \
     close #f10
     close #f11
    '\_________________/
     if RemarkMissed>0 then print "Remarks Missed=";RemarkMissed
     Ln=Ln+4
     call logit "Remarks Missed=";RemarkMissed
     call logit "Remarks Found=";RemarkFound
     Ln=Ln-8

end sub


